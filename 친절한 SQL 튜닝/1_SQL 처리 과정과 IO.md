# 1.1 SQL 파싱과 최적화
## 1.1.2 SQL 최적화
최적화 세분화 과정
1. SQL 파싱
사용자로부터 SQL을 전달받으면 가장 먼저 SQL 파서(Parser)가 파싱을 진행.
- 파싱 트리 생성 : SQL 문을 이루는 개별 구성요소를 분석해서 파싱 트리 생성
- Syntax 체크 : 문법적 오류가 없는지 확인. (문법 오류 등)
- Semantic 체크 : 의미상 오류가 없는지 확인. (존재하지 않는 컬럼 사용 등)

2. SQL 최적화
옵티마이저(Optimizer)가 미리 수집한 시스템 및 오브젝트 통계정보를 바탕으로 다양한 실행경로를 생성, 비교 후 가장 효율적인 하나를 선택.

3. 로우 소스 생성
옵티마이저가 선택한 실행경로를 실제 실행 가능한 코드, 프로시저 형태로 포멧팅. 로우 소스 생성기(Row-Source Generator)가 그 역할을 맡음.

## 1.1.3 SQL 옵티마이저
1. 사용자로부터 전달받은 쿼리를 수행 시, 후보군들의 실행계획들을 찾아냄.
2. 데이터 딕셔너리에 미리 수집해 둔 오브젝트 통계 및 시스템 통계정보를 이용해 각 실행계획의 예상비용 산정.
3. 최저 비용을 나타내는 실행계획을 선택

## 1.1.4 실행계획과 비용
## 1.1.5 옵티마이저 힌트
옵티마이저는 네비게이션과 같다. 경로를 변경 가능하고, 반드시 옳은 길만을 안내하는 것도 아니다.

SELECT --+ INDEX(A 고객_PK)
고객명, 연락처
FROM 고객 A
WHERE 고객ID = '00008';

힌트 안에 인자를 나열할 땐 ,를 사용할 수 있지만, 힌트와 힌트 사이에 사용하면 안 된다.
/*+ INDEX(A 고객_PK) INDEX(B, 고객_PK) */ 둘 다 유효
/*+ INDEX(C) FULL(D) */ 첫번째만 유효

테이블을 지정할 때 아래와 같이 스키마명까지 명시하면 안 된다.
SELECT /*+ FULL(SCOTT.EMP)*/ -> 무효
FROM EMP

FROM 절 테이블명 옆에 ALIAS를 지정했다면, 힌트에도 반드시 ALIAS를 사용해야 한다.
SELECT /*+ FULL(EMP)*/ -> 무효
FROM EMP

# 1.2 SQL 공유 및 재사용
## 1.2.1 소프트 파싱 vs 하드 파싱
SQL 파싱, 최적화, 로우 소스 생성 과정을 거쳐 생성한 내부 프로시저를 반복 재사용할 수 있도록 캐싱해 두는 메모리 공간 = 라이브러리 캐시 (Library Cache)
라이브러리 캐시는 SGA(System Global Area)는 서버 프로세스와 백그라운드 프로세스가 공통으로 액세스하는 데이터와 제어 구조를 캐싱하는 메모리 공간이다.

SQL을 캐시에서 찾아 곧바로 실행단계로 넘어간다면 소프트 파싱(Soft Parsing), 실패해서 최적화 및 로우 소스 생성 단계까지 모두 거치는 것을 하드 파싱(Hard Parsing)이라고 한다.

옵티마이저가 최적화 과정에 사용하는 정보 
1. 테이블, 컬럼, 인덱스 구조에 관한 기본 정보
2. 오브젝트 통계 : 테이블 통계, 인덱스 통계, (히스토그램을 포함한) 컬럼 통계
3. 시스템 통계 : CPU 속도, Single Block I/O 속도, Multiblock I/O 속도 등
4. 옵티마이저 관련 파라미터

하드 파싱은 굉장히 무거운 작업이며, 한 번 사용하고 버리는것은 크나큰 낭비. 그러므로 라이브러리 캐시가 필요.
