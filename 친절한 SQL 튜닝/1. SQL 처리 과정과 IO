# 1.1 SQL 파싱과 최적화
## 1.1.2 SQL 최적화
최적화 세분화 과정
1. SQL 파싱
사용자로부터 SQL을 전달받으면 가장 먼저 SQL 파서(Parser)가 파싱을 진행.
- 파싱 트리 생성 : SQL 문을 이루는 개별 구성요소를 분석해서 파싱 트리 생성
- Syntax 체크 : 문법적 오류가 없는지 확인. (문법 오류 등)
- Semantic 체크 : 의미상 오류가 없는지 확인. (존재하지 않는 컬럼 사용 등)

2. SQL 최적화
옵티마이저(Optimizer)가 미리 수집한 시스템 및 오브젝트 통계정보를 바탕으로 다양한 실행경로를 생성, 비교 후 가장 효율적인 하나를 선택.

3. 로우 소스 생성
옵티마이저가 선택한 실행경로를 실제 실행 가능한 코드, 프로시저 형태로 포멧팅. 로우 소스 생성기(Row-Source Generator)가 그 역할을 맡음.

## 1.1.3 SQL 옵티마이저
1. 사용자로부터 전달받은 쿼리를 수행 시, 후보군들의 실행계획들을 찾아냄.
2. 데이터 딕셔너리에 미리 수집해 둔 오브젝트 통계 및 시스템 통계정보를 이용해 각 실행계획의 예상비용 산정.
3. 최저 비용을 나타내는 실행계획을 선택

## 1.1.4 실행계획과 비용
## 1.1.5 옵티마이저 힌트
옵티마이저는 네비게이션과 같다. 경로를 변경 가능하고, 반드시 옳은 길만을 안내하는 것도 아니다.

SELECT --+ INDEX(A 고객_PK)
고객명, 연락처
FROM 고객 A
WHERE 고객ID = '00008';

힌트 안에 인자를 나열할 땐 ,를 사용할 수 있지만, 힌트와 힌트 사이에 사용하면 안 된다.
/*+ INDEX(A 고객_PK) INDEX(B, 고객_PK) */ 둘 다 유효
/*+ INDEX(C) FULL(D) */ 첫번째만 유효

테이블을 지정할 때 아래와 같이 스키마명까지 명시하면 안 된다.
SELECT /*+ FULL(SCOTT.EMP)*/ -> 무효
FROM EMP

FROM 절 테이블명 옆에 ALIAS를 지정했다면, 힌트에도 반드시 ALIAS를 사용해야 한다.
SELECT /*+ FULL(EMP)*/ -> 무효
FROM EMP
