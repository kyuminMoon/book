# 유니크 인덱스
사실 인덱스라기보다 제약조건에 가깝다. MySQL에선 인덱스 없이 유니크 제약만 설정할 방법이 없다. 유니크 인덱스에서 NULL도 저장될 수 있는데, NULL은 특정 값이 아니므로 2개 이상 저장될 수 있다. MyISAM이나 MEMORY 테이블에서 PK는 사실 NULL이 허용되지 않는 유니크 인덱스와 같지만, InnoDB 테이블의 PK는 클러스터링 키의 역할도 하므로 UK 인덱스와는 근본적으로 다르다.

## 유니크 인덱스와 일반 세컨더리 인덱스의 비교
유니크 인덱스와 유니크하지 않은 일반 세컨더리 인덱스는 사실 인덱스의 구조상 아무 차이가 없다. 읽기와 쓰기 성능 관점에서 한번 살펴보자.

### 인덱스 읽기
유니크하지 않은 세컨더리 인덱스에서 한 번 더 해야 하는 작업은 디스크 읽기가 아니라 CPU에서 컬럼값을 비교하는 작업이기 때문에 이는 성능상 영향이 거의 없다고 볼 수 있다. 유니크하지 않은 세컨더리 인덱스는 중복된 값이 허용되므로 읽어야 할 레코드가 많아서 느린 것이지, 인덱스 자체의 특성 때문에 느린 것이 아니라는 것. 이로인해 유니크 인덱스가 빠르다고 생각하는건 사실이 아니다.
즉 레코드 1건을 읽는 데 0.1초가 걸렸고, 2건을 읽을 때 0.2초가 걸렸다고 할 때 후자를 느리게 처리됐다고 할 수 없는 것과 같은 이치. 

하나의 값을 검색하는 경우 유니크 인덱스와 일반 세컨더리 인덱스는 사용되는 실행 계획이 다르다. 하지만 이는 인덱스의 성격이 유니크한지 아닌지에 따른 차이일 뿐이지 큰 차이는 없다. 읽어야 할 레코드 건수가 같다면 성능상의 차이는 미미하다.

### 인덱스 쓰기
새로운 레코드가 INSERT 되거나, 인덱스 컬럼의 값이 변경되는 경우엔 인덱스 쓰기 작업이 필요. 그런데 유니크 인덱스 키 값을 쓸 땐 중복된 값이 있는지 없는지 체크하는 과정이 필요하다. 유니크하지 않은 세컨더리 인덱스의 쓰기보다 느림.

MySQL에선 중복된 값을 체크할 땐 읽기 잠금을 사용하고, 쓰기를 할 땐 쓰기 잠금을 사용하는데 이 과정에서 데드락이 빈번히 발생.

또한 InnoDB엔 인덱스 키의 저장을 버퍼링 하기 위해 체인지 버퍼(Change Buffer)가 사용된다. 그래서 인덱스의 저장이나 변경 작업이 상당히 빨리 처리되지만, 안타깝게도 유니크 인덱스는 반드시 중복 체크를 해야 하므로 작업 자체를 버퍼링하지 못한다. 이 특징 때문에 일반 세컨더리 인덱스보다 변경 작업이 더 느리게 작동.

## 유니크 사용 시 주의사항
성능이 좋아질 것으로 생각하고 불필요하게 유니크 인덱스를 생성하지는 않는 것이 좋다.
하나의 테이블에서 같은 컬럼에 유니크 인덱스와 일반 인덱스를 각각 중복해서 생성해 둔 경우, MySQL의 유니크 인덱스는 다른 인덱스와 같은 역할을 하므로 중복해서 인덱스를 생성할 필요는 없다.
다음과 같은 경우 이미 nick_name이라는 컬럼에 대해선 유니크 인덱스인 ux_nickname이 있기 떄문에 ix_nickname 인덱스는 필요하지 않다.


```sql
CREATE TABLE user(
emp_no INT NOT NULL,
first_name VARCHAR(10),
last_name VARCHAR(10),
PRIMARY KEY (emp_no),
INDEX ix_firstname(first_name)
);

SELECT * FROM employees WHERE first_name='Aamer';
```